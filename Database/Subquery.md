# *Subquery*
메인쿼리는 서브쿼리의 컬럼을 참조할 수 없음, FROM 절 서브퀘리의 경우 메인쿼리는 참조할 수 있음  
ORDER BY 도 마찬가지
## SELECT WHERE SUBQUERY
- - -
```mysql
# Single Value Subquery
SELECT
FROM
WHERE expr 비교연산자 (subquery);

# Multi Value Subquery
SELECT
FROM
WHERE expr 비교연산자 {ANY | SOME | ALL} (subquery);

# Multi-row Subquery
SELECT
FROM
WHERE expr [NOT] IN (subquery);  # multiple or

SELECT
FROM
WHERE [NOT] EXISTS (subquery);  # 조건을 만족하는 투플을 찾으면 더이상 검색하지 않음

# Correlated Subquery

```
```mysql
# example
# 선수들의 평균 키보다 작은 선수들을 검색.
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE HEIGHT <= (
SELECT AVG(HEIGHT)
FROM PLAYER
)
ORDER BY PLAYER_NAME; 

# 정현수 선수의 소속팀 정보를 검색.
SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID = ( SELECT TEAM_ID
FROM PLAYER
WHERE PLAYER_NAME = '정현수'
)
ORDER BY TEAM_NAME; /* 에러: 2개 행이 리턴됨 */

SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID = ANY (
SELECT TEAM_ID
FROM PLAYER
WHERE PLAYER_NAME = '정현수'
)
ORDER BY TEAM_NAME;

# 동일한 질의
SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID IN (
SELECT TEAM_ID /* 1-tuple의 집합 */
FROM PLAYER
WHERE PLAYER_NAME = '정현수'
)
ORDER BY TEAM_NAME;


#  팀에서 제일 키가 작은 선수들을 검색.
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, POSITION 포지션,
BACK_NO 백넘버, HEIGHT 키
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN ( /* n-tuple의 집합 */
	SELECT TEAM_ID, MIN(HEIGHT)
	FROM PLAYER
	GROUP BY TEAM_ID
)
ORDER BY TEAM_ID, PLAYER_NAME; 

# 포지션이 GK인 선수들을 검색
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, POSITION 포지션,
BACK_NO 백넘버, HEIGHT 키
FROM PLAYER X
WHERE EXISTS (
SELECT * # * 대신 PLAYER의 어떤 속성도 가능
FROM PLAYER Y
WHERE X.PLAYER_ID = Y.PLAYER_ID AND
Y.POSITION = 'GK'
);

# 브라질 혹은 러시아 출신 선수가 있는 팀을 검색.
SELECT TEAM_ID, TEAM_NAME
FROM TEAM T
WHERE TEAM_ID = ANY (
SELECT TEAM_ID
FROM PLAYER P
WHERE T.TEAM_ID = P.TEAM_ID AND
(P.NATION = '브라질' OR P.NATION = '러시아')
);

# 20120501부터 20120502 사이에 경기가 열렸던 경기장을 조회.
SELECT STADIUM_ID ID, STADIUM_NAME 경기장명
FROM STADIUM ST
WHERE EXISTS (
SELECT 1 /* 1 대신 *도 가능 */
FROM SCHEDULE SC
WHERE ST.STADIUM_ID = SC.STADIUM_ID AND
SC.SCHE_DATE BETWEEN '20120501' AND '20120502'
);

# 각 팀에서 제일 키가 큰 선수들을 검색.
SELECT TEAM_ID, PLAYER_NAME, HEIGHT
FROM PLAYER X
WHERE HEIGHT = (
SELECT MAX(HEIGHT)
FROM PLAYER Y
WHERE X.TEAM_ID = Y.TEAM_ID
)
ORDER BY TEAM_ID;

# 소속 팀의 평균 키보다 작은 선수들을 검색
SELECT X.TEAM_ID, X.PLAYER_NAME 선수명,
X.POSITION 포지션, X.BACK_NO 백넘버, X.HEIGHT 키
FROM PLAYER X
WHERE X.HEIGHT < (
SELECT AVG(Y.HEIGHT)
FROM PLAYER Y
WHERE X.TEAM_ID = Y.TEAM_ID
)
ORDER BY X.TEAM_ID, 키, 선수명
```
## NOT SELECT WHERE SUBQUERY
- - -
### Scalar Subquery (SELECT 절 서브쿼리)
```mysql
# 선수 정보와 소속 팀의 평균 키를 함께 검색.
SELECT TEAM_ID, PLAYER_NAME 선수명, HEIGHT 키,
(
SELECT AVG(HEIGHT)
FROM PLAYER Y // TEAM_ID로 그룹핑
WHERE X.TEAM_ID = Y.TEAM_ID
) 팀평균키
FROM PLAYER X;

#  팀명과 소속 선수의 인원수를 검색.
SELECT TEAM_ID, TEAM_NAME,
(
SELECT COUNT(*)
FROM PLAYER Y
WHERE X.TEAM_ID = Y.TEAM_ID
) 팀인원수
FROM TEAM X
ORDER BY TEAM_ID;

# 각 팀의 마지막 경기가 진행된 날짜를 검색.
SELECT TEAM_ID, TEAM_NAME,
(
SELECT MAX(SCHE_DATE)
FROM SCHEDULE S
WHERE T.TEAM_ID = S.HOMETEAM_ID OR
T.TEAM_ID = S.AWAYTEAM_ID
) '최종 경기일‘
FROM TEAM T;

```
### Inline View (FROM 절 서브쿼리)
서브쿼리의 결과를 동적으로 생성한 테이블인 것처럼 사용한다
```mysql
# K09 팀의 선수 이름, 포지션, 백넘버를 검색
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM (
SELECT TEAM_ID, PLAYER_ID, PLAYER_NAME,
POSITION, BACK_NO
FROM PLAYER
ORDER BY PLAYER_ID DESC
) AS TEMP # inline view에 반드시 table alias를 정의해야 함. 
WHERE TEAM_ID = 'K09';

# 동일한 질의
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM (
SELECT TEAM_ID, PLAYER_ID, PLAYER_NAME,
POSITION, BACK_NO
FROM PLAYER
ORDER BY PLAYER_ID DESC
) AS TEMP
WHERE TEAM_ID = 'K09';

WITH TEMP AS
(
SELECT TEAM_ID, PLAYER_ID, PLAYER_NAME, POSITION, BACK_NO
FROM PLAYER
ORDER BY PLAYER_ID DESC
)
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM TEMP
WHERE TEAM_ID = 'K09'; 


# 포지션이 MF인 선수들의 소속팀명 및 선수 정보를 검색.
SELECT T.TEAM_NAME 팀명, P.PLAYER_NAME 선수명, P.BACK_NO 백넘버
FROM (
SELECT TEAM_ID, PLAYER_NAME, BACK_NO
FROM PLAYER
WHERE POSITION = 'MF'
) P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
ORDER BY 선수명; 

# 키가 제일 큰 5명 선수들의 정보를 검색 (top-N query)
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버,
HEIGHT 키
FROM (
SELECT PLAYER_NAME, POSITION, BACK_NO, HEIGHT
FROM PLAYER
WHERE HEIGHT IS NOT NULL
ORDER BY HEIGHT DESC
) AS TEMP
LIMIT 5; 
```
### HAVING 절 서브쿼리
```mysql
# : K02 팀의 평균키 보다 평균키가 작은 팀의 이름과 해당 팀의 평균키를 검색.
SELECT T.TEAM_ID 팀코드, T.TEAM_NAME 팀명, AVG(P.HEIGHT) 평균키
FROM TEAM T JOIN PLAYER P ON T.TEAM_ID = P.TEAM_ID
GROUP BY T.TEAM_ID, T.TEAM_NAME
HAVING AVG(P.HEIGHT) < (
SELECT AVG(HEIGHT)
FROM PLAYER
WHERE TEAM_ID ='K02'
);
```
## Update 문의 Subquery
- - -
```mysql
# update subquery
ALTER TABLE TEAM
ADD COLUMN STADIUM_NAME VARCHAR(40);
UPDATE TEAM T
SET T.STADIUM_NAME = (
SELECT S.STADIUM_NAME
FROM STADIUM S
WHERE T.STADIUM_ID = S.STADIUM_ID
);
SELECT TEAM_NAME, STADIUM_ID, STADIUM_NAME
FROM TEAM;

```
```mysql
# insert subquery
INSERT INTO PLAYER(PLAYER_ID, PLAYER_NAME, TEAM_ID) VALUES
(
	(
	SELECT TO_CHAR(MAX(TO_NUMBER(PLAYER_ID))+1)
	FROM PLAYER
	),
	'홍길동', 'K06'
); 
```